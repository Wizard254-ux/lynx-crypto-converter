## ğŸ§© Milestone 2 â€“ Conversion Engine & Wallet Integration Plan

**Duration:** 3 days (Day 3â€“5)
**Goal:** Build a robust, secure, and accurate conversion engine with wallet mapping, live rates, and error handling.

---

### 1. Core Objectives

| Feature                               | Description                                                                                                                     | Deliverable                       |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | --------------------------------- |
| **Conversion Logic**                  | Convert fiat balance values to equivalent amounts in selected cryptocurrencies (BTC, ETH, USDT, SOL) using live exchange rates. | `converter.py` core logic         |
| **Live Rate Integration (CoinGecko)** | Fetch and cache crypto rates using CoinGecko API; automatically refresh every X minutes.                                        | `rate_service.py` module          |
| **Offline Fallback**                  | Use a locally cached JSON of previous rates if API is unreachable.                                                              | `fallback_rates.json` + logic     |
| **Wallet Association**                | Bind converted values to client-provided wallet addresses (loaded from JSON or env variables).                                  | Wallet linking subsystem          |
| **Error Handling & Logging**          | Robust handling of malformed files, failed API calls, or invalid wallets, with timestamped logs.                                | `logger.py` + structured logs     |
| **Conversion Accuracy Validation**    | Use `decimal.Decimal` for precise rounding to avoid float inaccuracies. Validate results within Â±0.1% tolerance.                | Unit-tested accuracy verification |

---

### 2. System Architecture Diagram

```
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚  balances.docx     â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                [Step 1] Parse Balances
                           â”‚
                           â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚  Converter Engine  â”‚
                 â”‚ (converter.py)     â”‚
                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                        â”‚       â”‚
         [API Rates]    â”‚       â”‚   [Offline Fallback]
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ CoinGecko API   â”‚â”€â”€â”˜       â””â”€â–¶â”‚ fallback_rates.json â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  Wallet Associationâ”‚
              â”‚  (wallet_service.py) â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚   Conversion Results  â”‚
             â”‚ (JSON or CSV + log)   â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 3. Detailed Task Breakdown

#### ğŸ”¹ A. Conversion Logic

**Files:** `converter.py`

* Accept input balances (float or decimal).
* Fetch live rates from `rate_service.py`.
* Perform conversion for each currency:

  ```python
  crypto_amount = Decimal(balance) / Decimal(rate_in_usd)
  ```
* Round results to 8 decimal places for precision.
* Output format (JSON example):

  ```json
  {
    "timestamp": "2025-11-04T12:30:00Z",
    "conversions": {
      "USD": 5000,
      "BTC": 0.085,
      "ETH": 1.32,
      "USDT": 4999.8
    }
  }
  ```

#### ğŸ”¹ B. CoinGecko API Integration

**Files:** `rate_service.py`

* Use `requests` to call:

  ```
  https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,tether,solana&vs_currencies=usd
  ```
* Parse JSON to map `{ "BTC": rate, "ETH": rate, "USDT": rate, "SOL": rate }`
* Cache rates locally (`fallback_rates.json`)
* Implement a **retry mechanism** and **graceful degradation** (use cached rates if API fails).

#### ğŸ”¹ C. Fallback Mechanism

* Maintain `fallback_rates.json` updated after each successful API call.
* Auto-detect network failure and switch to offline rates with a log warning:

  ```
  [WARN] Using offline rates â€“ API unreachable
  ```

#### ğŸ”¹ D. Wallet Address Association

**Files:** `wallet_service.py`

* Load wallets from a JSON file:

  ```json
  {
    "BTC": "1A2b3C4d5E6f...",
    "ETH": "0xAbC123...",
    "USDT": "TAbC123..."
  }
  ```
* Validate each address format using regex or checksum libraries (`bitcoinaddress`, `eth_utils`, etc.).
* Associate converted amounts with each address:

  ```json
  { "BTC": {"address": "1A2b3...", "amount": 0.085}, ... }
  ```

#### ğŸ”¹ E. Error Handling & Logging

**Files:** `logger.py`

* Use `logging` module with rotating file handler.
* Store logs in `logs/converter.log`
* Log types:

  * `[INFO] Conversion successful for balances.docx`
  * `[ERROR] API request failed: <error>`
  * `[WARN] Invalid wallet address format detected`
* Exception-safe wrappers around API and file I/O calls.

#### ğŸ”¹ F. Conversion Accuracy Validation

* Use `decimal.Decimal` for deterministic rounding.
* Write test script `test_conversion_accuracy.py`:

  * Compare computed vs. expected results.
  * Assert variance â‰¤ 0.1%.
  * Example:

    ```python
    assert abs(calc - expected) / expected < Decimal("0.001")
    ```

---

### 4. Deliverables

| Deliverable                               | Description                        |
| ----------------------------------------- | ---------------------------------- |
| âœ… `converter.py`                          | Main engine performing conversions |
| âœ… `rate_service.py`                       | API + fallback rate manager        |
| âœ… `wallet_service.py`                     | Wallet validation and linking      |
| âœ… `logger.py`                             | Logging utility with rotation      |
| âœ… `test_conversion_accuracy.py`           | Validation and test scripts        |
| âœ… `demo_data/`                            | Sample balance + wallets JSON      |
| âœ… Logs + demo run video or screenshots    |                                    |
| âœ… Technical documentation (README update) |                                    |

---

### 5. Verification Checklist (Preâ€“Milestone 3)

| Checkpoint                   | Criteria                               |
| ---------------------------- | -------------------------------------- |
| âœ… Conversion results correct | Compare values with CoinGecko manually |
| âœ… Offline mode works         | Disconnect network, run test           |
| âœ… Wallets linked correctly   | Each currency maps to valid address    |
| âœ… Logs generated properly    | Check `logs/converter.log`             |
| âœ… API call resilience        | Handle 404 / timeout gracefully        |
| âœ… Documentation updated      | README + inline docstrings complete    |

---

### 6. Optional Enhancements (If Time Permits)

* Add **rate refresh scheduling** (e.g., every 15 mins).
* Integrate **SQLite** or **TinyDB** for persistent transaction history.
* Add **conversion fee simulation** (configurable % deduction).
* Implement **unit test coverage â‰¥80%** using `pytest`.

---

### ğŸ”š Summary of Milestone 2 Outcome

By the end of this milestone, you should have:

* A **fully functional conversion engine** (with live and fallback rate sources),
* A **wallet association system** with validation,
* A **structured logging mechanism**,
* A **demo-ready flow** showing parsed balances â†’ converted crypto â†’ wallet mapping â†’ logged output.
